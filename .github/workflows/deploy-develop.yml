name: Deploy to Main

on:
  push:
    branches:
      - main

env:
  NODE_VERSION: '20'
  GO_VERSION: '1.25'

jobs:
  # CI: Build and test
  ci:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Frontend: Lint and Build
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: |
          # Note: Using npm install instead of npm ci because package-lock.json 
          # needs to be updated with new dependencies. After updating the lock file
          # locally, switch back to 'npm ci' for faster, reproducible builds.
          npm install

      - name: Lint frontend
        working-directory: ./frontend
        run: npm run lint
        continue-on-error: true  # Allow warnings in CI for now - TODO: Fix React Hook dependency warnings

      - name: Build frontend
        working-directory: ./frontend
        run: npm run build
        env:
          VITE_API_BASE_URL: ${{ secrets.FRONTEND_API_URL || 'https://api.stackyn.com' }}

      # Backend: Build verification
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Verify backend builds
        working-directory: ./server
        run: |
          go mod download
          go mod verify
          go build -o /tmp/api ./cmd/api
          go build -o /tmp/build-worker ./cmd/build-worker
          go build -o /tmp/deploy-worker ./cmd/deploy-worker
          go build -o /tmp/cleanup-worker ./cmd/cleanup-worker
          echo "‚úÖ All backend binaries built successfully"

  # CD: Deploy to staging
  deploy:
    needs: ci
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Detect key type and write accordingly
          SSH_KEY="${{ secrets.STAGING_SSH_KEY }}"
          if echo "$SSH_KEY" | grep -q "BEGIN.*ED25519"; then
            KEY_FILE=~/.ssh/id_ed25519
            echo "üîë Detected ED25519 key"
          elif echo "$SSH_KEY" | grep -q "BEGIN.*RSA"; then
            KEY_FILE=~/.ssh/id_rsa
            echo "üîë Detected RSA key"
          elif echo "$SSH_KEY" | grep -q "BEGIN"; then
            # Default to ed25519 if we can't determine
            KEY_FILE=~/.ssh/id_ed25519
            echo "üîë Using default key file (ed25519)"
          else
            echo "‚ö†Ô∏è  Warning: SSH key format not recognized. Ensure STAGING_SSH_KEY includes full key with headers."
            KEY_FILE=~/.ssh/id_ed25519
          fi
          
          # Write SSH key (preserve newlines)
          echo "$SSH_KEY" > "$KEY_FILE"
          chmod 600 "$KEY_FILE"
          
          # Add host to known_hosts
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts 2>/dev/null
          chmod 644 ~/.ssh/known_hosts
          
          # Create SSH config with keepalive settings
          cat > ~/.ssh/config << EOF
          Host ${{ secrets.STAGING_HOST }}
            ServerAliveInterval 60
            ServerAliveCountMax 10
            TCPKeepAlive yes
            Compression no
            ControlMaster auto
            ControlPath ~/.ssh/control-%h-%p-%r
            ControlPersist 10m
          EOF
          chmod 600 ~/.ssh/config
          
          # Test SSH connection
          echo "üîç Testing SSH connection..."
          ssh -i "$KEY_FILE" -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes root@${{ secrets.STAGING_HOST }} "echo 'SSH connection successful'" || {
            echo "‚ùå SSH connection test failed"
            echo "Key file: $KEY_FILE"
            echo "Key file exists: $(test -f "$KEY_FILE" && echo 'yes' || echo 'no')"
            if [ -f "$KEY_FILE" ]; then
              echo "Key file permissions: $(ls -la "$KEY_FILE")"
              echo "Key file first line: $(head -n1 "$KEY_FILE")"
              echo "Key file last line: $(tail -n1 "$KEY_FILE")"
            fi
            echo ""
            echo "üí° Troubleshooting tips:"
            echo "1. Ensure STAGING_SSH_KEY secret includes the full private key with headers"
            echo "2. Verify the key is added to the server's authorized_keys"
            echo "3. Check that STAGING_HOST is correct"
            exit 1
          }
          
          # Export key file path for use in deployment step
          echo "KEY_FILE=$KEY_FILE" >> $GITHUB_ENV
          echo "‚úÖ SSH setup complete. Using key: $KEY_FILE"

      - name: Deploy to staging
        run: |
          # Try to use detected key file, fallback to common key types
          if [ -f "${{ env.KEY_FILE }}" ]; then
            KEY_FILE="${{ env.KEY_FILE }}"
          elif [ -f ~/.ssh/id_ed25519 ]; then
            KEY_FILE=~/.ssh/id_ed25519
          elif [ -f ~/.ssh/id_rsa ]; then
            KEY_FILE=~/.ssh/id_rsa
          else
            echo "‚ùå No SSH key found"
            exit 1
          fi
          
          # Use SSH with keepalive and run deployment in a way that won't timeout
          ssh -i "$KEY_FILE" \
            -o StrictHostKeyChecking=no \
            -o BatchMode=yes \
            -o ServerAliveInterval=60 \
            -o ServerAliveCountMax=10 \
            -o TCPKeepAlive=yes \
            root@${{ secrets.STAGING_HOST }} << 'DEPLOY_SCRIPT'
          set -e  # Exit on error
          
          echo "üöÄ Starting deployment..."
          cd /opt/stackyn
          
          # Backup current deployment
          echo "üì¶ Creating backup..."
          if [ -d ".git" ]; then
            git stash || true
            CURRENT_COMMIT=$(git rev-parse HEAD)
            echo "Current commit: $CURRENT_COMMIT"
          fi
          
          # Pull latest code
          echo "üì• Pulling latest code..."
          git checkout develop
          git pull origin develop
          NEW_COMMIT=$(git rev-parse HEAD)
          echo "New commit: $NEW_COMMIT"
          
          # Ensure environment variables are set
          echo "üîç Checking environment configuration..."
          if [ ! -f .env ]; then
            echo "‚ö†Ô∏è  Warning: .env file not found."
            # Try env.example first (the actual file name), then .env.production.example as fallback
            if [ -f env.example ]; then
              echo "üìã Creating .env from env.example template..."
              cp env.example .env
              echo "‚úÖ Created .env from env.example"
            elif [ -f .env.production.example ]; then
              echo "üìã Creating .env from .env.production.example template..."
              cp .env.production.example .env
              echo "‚úÖ Created .env from .env.production.example"
            else
              echo "‚ùå No .env file or template found. Deployment cannot continue."
              echo "   Looking for: env.example or .env.production.example"
              exit 1
            fi
          else
            echo "‚úÖ .env file exists"
            # Check if APP_BASE_DOMAIN is missing and add it if needed
            if ! grep -q "^APP_BASE_DOMAIN=" .env; then
              echo "‚ö†Ô∏è  APP_BASE_DOMAIN not found in .env, adding it..."
              if [ -f env.example ] && grep -q "^APP_BASE_DOMAIN=" env.example; then
                # Extract APP_BASE_DOMAIN from env.example and append to .env
                grep "^APP_BASE_DOMAIN=" env.example >> .env
                echo "‚úÖ Added APP_BASE_DOMAIN to .env"
              else
                # Add default value (use stackyn.com as default)
                echo "APP_BASE_DOMAIN=stackyn.com" >> .env
                echo "‚úÖ Added APP_BASE_DOMAIN=stackyn.com to .env"
              fi
            fi
          fi

            # FORCE UPDATE to production domains
            echo "üîß Enforcing production domains in .env..."
            sed -i 's|FRONTEND_API_URL=.*|FRONTEND_API_URL=https://api.stackyn.com|g' .env
            sed -i 's|FRONTEND_DOMAIN=.*|FRONTEND_DOMAIN=stackyn.com|g' .env
            sed -i 's|API_DOMAIN=.*|API_DOMAIN=api.stackyn.com|g' .env
            sed -i 's|CONSOLE_DOMAIN=.*|CONSOLE_DOMAIN=console.stackyn.com|g' .env
            sed -i 's|APP_BASE_DOMAIN=.*|APP_BASE_DOMAIN=stackyn.com|g' .env
            echo "‚úÖ Updated .env to use stackyn.com domains"
          
          # Verify critical environment variables are set
          echo "‚úÖ Verifying critical environment variables..."
          source .env || true
          MISSING_VARS=()
          [ -z "$POSTGRES_PASSWORD" ] && MISSING_VARS+=("POSTGRES_PASSWORD")
          [ -z "$JWT_SECRET" ] && MISSING_VARS+=("JWT_SECRET")
          [ -z "$API_DOMAIN" ] && MISSING_VARS+=("API_DOMAIN")
          [ -z "$APP_BASE_DOMAIN" ] && MISSING_VARS+=("APP_BASE_DOMAIN")
          [ -z "$ACME_EMAIL" ] && MISSING_VARS+=("ACME_EMAIL")
          
          if [ ${#MISSING_VARS[@]} -ne 0 ]; then
            echo "‚ùå Missing required environment variables:"
            for var in "${MISSING_VARS[@]}"; do
              echo "   - $var"
            done
            echo ""
            echo "üí° Solution:"
            echo "   1. SSH into the VPS: ssh root@${{ secrets.STAGING_HOST }}"
            echo "   2. Edit .env: cd /opt/stackyn && nano .env"
            echo "   3. Add missing variables (see env.example for format)"
            echo "   4. Redeploy"
            exit 1
          fi
          
          echo "‚úÖ All required environment variables are set"
          
          echo "‚úÖ Environment variables verified"
          
          # Build and deploy
          echo "üî® Building and deploying containers..."
          
          # CRITICAL: Preserve SSL certificates by ensuring traefik_data volume is not removed
          echo "üîê Protecting SSL certificates..."
          docker volume inspect stackyn_traefik_data >/dev/null 2>&1 && echo "‚úÖ SSL certificate volume exists and will be preserved" || echo "‚ö†Ô∏è  SSL certificate volume not found (will be created)"
          
          # Stop and remove existing containers and networks (EXPLICITLY preserve volumes)
          # Using --volumes flag would remove volumes - we DO NOT want that for SSL certificates
          echo "üõë Stopping existing containers (preserving volumes for SSL certificates and data)..."
          docker compose down --remove-orphans || true  # NO --volumes flag to preserve SSL certificates
          
          # Wait a moment for ports to be released
          sleep 3
          
          # Find and stop any containers using port 8080
          echo "üîç Finding containers using port 8080..."
          CONTAINERS_ON_8080=$(docker ps --filter "publish=8080" --format "{{.ID}} {{.Names}}" 2>/dev/null || true)
          if [ ! -z "$CONTAINERS_ON_8080" ]; then
            echo "‚ö†Ô∏è  Found containers using port 8080:"
            echo "$CONTAINERS_ON_8080"
            echo "üõë Stopping these containers..."
            docker ps --filter "publish=8080" --format "{{.ID}}" | xargs -r docker stop 2>/dev/null || true
            docker ps -a --filter "publish=8080" --format "{{.ID}}" | xargs -r docker rm -f 2>/dev/null || true
            sleep 2
          else
            echo "‚úÖ No containers found using port 8080"
          fi
          
          # Check for and kill processes using port 8080 (API port)
          echo "üîç Checking for processes using port 8080..."
          if command -v lsof >/dev/null 2>&1; then
            PID=$(lsof -ti:8080 2>/dev/null) && kill -9 $PID 2>/dev/null && echo "‚úÖ Killed process on port 8080 (PID: $PID)" || echo "‚úÖ Port 8080 is free"
          elif command -v fuser >/dev/null 2>&1; then
            fuser -k 8080/tcp 2>/dev/null && echo "‚úÖ Killed process on port 8080" || echo "‚úÖ Port 8080 is free"
          elif command -v netstat >/dev/null 2>&1; then
            # Fallback: use netstat to find and kill process
            PID=$(netstat -tlnp 2>/dev/null | grep ':8080' | awk '{print $7}' | cut -d'/' -f1 | head -1)
            if [ ! -z "$PID" ] && [ "$PID" != "-" ]; then
              kill -9 $PID 2>/dev/null && echo "‚úÖ Killed process on port 8080 (PID: $PID)" || echo "‚úÖ Port 8080 is free"
            else
              echo "‚úÖ Port 8080 is free"
            fi
          else
            echo "‚ö†Ô∏è  Could not check port 8080 (lsof/fuser/netstat not available)"
          fi
          
          # Remove any dangling containers that might be using the port
          # IMPORTANT: Do NOT remove containers that might be using the traefik_data volume
          echo "üßπ Cleaning up dangling containers (preserving SSL certificate volume)..."
          docker ps -a --filter "name=stackyn" --format "{{.ID}} {{.Names}}" | grep -v "traefik" | awk '{print $1}' | xargs -r docker rm -f 2>/dev/null || true
          
          # Explicitly ensure traefik_data volume is not removed
          echo "üîê Verifying SSL certificate volume is safe..."
          if docker volume inspect stackyn_traefik_data >/dev/null 2>&1; then
            CERT_SIZE=$(docker run --rm -v stackyn_traefik_data:/letsencrypt alpine sh -c "stat -c%s /letsencrypt/acme.json 2>/dev/null || echo 0")
            if [ "$CERT_SIZE" -gt 100 ]; then
              echo "‚úÖ SSL certificates found in volume ($CERT_SIZE bytes) - will be preserved"
            else
              echo "‚ö†Ô∏è  SSL certificate file is small or empty ($CERT_SIZE bytes) - will be recreated if needed"
            fi
          fi
          
          # Wait again for cleanup to complete
          sleep 2
          
          echo "‚úÖ Cleanup complete"
          
          # Build containers (this may take several minutes)
          # Use unbuffered output and keep connection alive
          echo "Building containers (this may take several minutes)..."
          if ! docker compose build --no-cache; then
            echo "‚ùå Build failed. Showing recent logs:"
            docker compose build --no-cache 2>&1 | tail -n 100
            exit 1
          fi
          
          # Initialize acme.json if it doesn't exist (for SSL certificates)
          # This will NOT overwrite existing certificates - only creates if missing
          echo "üîê Ensuring SSL certificate storage is ready..."
          docker volume inspect stackyn_traefik_data >/dev/null 2>&1 || docker volume create stackyn_traefik_data
          # Only initialize acme.json if it doesn't exist or is empty (preserve existing certificates)
          docker run --rm -v stackyn_traefik_data:/letsencrypt alpine sh -c "
            if [ ! -f /letsencrypt/acme.json ]; then
              echo 'Creating new acme.json file...'
              touch /letsencrypt/acme.json
              chmod 600 /letsencrypt/acme.json
              echo '{}' > /letsencrypt/acme.json
            else
              CERT_SIZE=\$(stat -c%s /letsencrypt/acme.json 2>/dev/null || echo 0)
              if [ \$CERT_SIZE -lt 100 ]; then
                echo 'acme.json exists but is too small, initializing...'
                echo '{}' > /letsencrypt/acme.json
                chmod 600 /letsencrypt/acme.json
              else
                echo 'Existing acme.json found (\$CERT_SIZE bytes) - preserving certificates'
              fi
            fi
          " || true
          
          echo "Starting containers (SSL certificates will be preserved)..."
          docker compose up -d --remove-orphans
          
          # Verify SSL certificate volume is still intact after deployment
          echo "üîê Verifying SSL certificates after deployment..."
          if docker volume inspect stackyn_traefik_data >/dev/null 2>&1; then
            CERT_SIZE=$(docker run --rm -v stackyn_traefik_data:/letsencrypt alpine sh -c "stat -c%s /letsencrypt/acme.json 2>/dev/null || echo 0")
            if [ "$CERT_SIZE" -gt 100 ]; then
              echo "‚úÖ SSL certificates preserved successfully ($CERT_SIZE bytes)"
            else
              echo "‚ö†Ô∏è  SSL certificate file is small - certificates may need to be regenerated"
            fi
          else
            echo "‚ùå ERROR: SSL certificate volume was removed! This should not happen."
          fi
          
          # Wait for services to be healthy
          echo "‚è≥ Waiting for services to start..."
          sleep 15
          
          # Health check
          echo "üè• Checking service health..."
          sleep 5  # Additional wait for services to initialize
          if docker compose ps | grep -q "Up"; then
            echo "‚úÖ Services are running"
            docker compose ps
          else
            echo "‚ùå Some services failed to start"
            docker compose ps
            echo "üìã Recent logs:"
            docker compose logs --tail=50
            exit 1
          fi
          
          # Verify API is responding
          echo "üîç Verifying API health..."
          sleep 10  # Wait for API to be ready
          API_URL="https://${API_DOMAIN:-api.stackyn.com}/health"
          if curl -f -s "$API_URL" > /dev/null 2>&1; then
            echo "‚úÖ API health check passed"
          else
            echo "‚ö†Ô∏è  API health check failed (may need more time or SSL certificate)"
            echo "   URL: $API_URL"
            echo "   This is normal if SSL certificates are still being generated."
          fi
          
          # Show recent logs
          echo "üìã Recent logs:"
          docker compose logs --tail=20
          
          echo ""
          echo "‚úÖ Deployment completed successfully!"
          echo "üåê Access your application at:"
          echo "   - Landing: https://${FRONTEND_DOMAIN:-stackyn.com}"
          echo "   - API: https://${API_DOMAIN:-api.stackyn.com}"
          echo ""
          echo "üí° Note: SSL certificates may take 5-10 minutes to generate on first deployment."
          DEPLOY_SCRIPT

      - name: Deployment status
        if: failure()
        run: |
          echo "‚ùå Deployment failed. Check the logs above for details."
          exit 1
