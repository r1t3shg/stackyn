name: Deploy to Develop

on:
  push:
    branches:
      - develop

env:
  NODE_VERSION: '20'
  GO_VERSION: '1.25'

jobs:
  # CI: Build and test
  ci:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Frontend: Lint and Build
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: |
          # Note: Using npm install instead of npm ci because package-lock.json 
          # needs to be updated with new dependencies. After updating the lock file
          # locally, switch back to 'npm ci' for faster, reproducible builds.
          npm install

      - name: Lint frontend
        working-directory: ./frontend
        run: npm run lint
        continue-on-error: true  # Allow warnings in CI for now - TODO: Fix React Hook dependency warnings

      - name: Build frontend
        working-directory: ./frontend
        run: npm run build
        env:
          VITE_API_BASE_URL: ${{ secrets.FRONTEND_API_URL || 'https://api.stackyn.com' }}

      # Backend: Build verification
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Verify backend builds
        working-directory: ./server
        run: |
          go mod download
          go mod verify
          go build -o /tmp/api ./cmd/api
          go build -o /tmp/build-worker ./cmd/build-worker
          go build -o /tmp/deploy-worker ./cmd/deploy-worker
          go build -o /tmp/cleanup-worker ./cmd/cleanup-worker
          echo "‚úÖ All backend binaries built successfully"

  # CD: Deploy to staging
  deploy:
    needs: ci
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Detect key type and write accordingly
          SSH_KEY="${{ secrets.STAGING_SSH_KEY }}"
          if echo "$SSH_KEY" | grep -q "BEGIN.*ED25519"; then
            KEY_FILE=~/.ssh/id_ed25519
            echo "üîë Detected ED25519 key"
          elif echo "$SSH_KEY" | grep -q "BEGIN.*RSA"; then
            KEY_FILE=~/.ssh/id_rsa
            echo "üîë Detected RSA key"
          elif echo "$SSH_KEY" | grep -q "BEGIN"; then
            # Default to ed25519 if we can't determine
            KEY_FILE=~/.ssh/id_ed25519
            echo "üîë Using default key file (ed25519)"
          else
            echo "‚ö†Ô∏è  Warning: SSH key format not recognized. Ensure STAGING_SSH_KEY includes full key with headers."
            KEY_FILE=~/.ssh/id_ed25519
          fi
          
          # Write SSH key (preserve newlines)
          echo "$SSH_KEY" > "$KEY_FILE"
          chmod 600 "$KEY_FILE"
          
          # Add host to known_hosts
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts 2>/dev/null
          chmod 644 ~/.ssh/known_hosts
          
          # Create SSH config with keepalive settings
          cat > ~/.ssh/config << EOF
          Host ${{ secrets.STAGING_HOST }}
            ServerAliveInterval 60
            ServerAliveCountMax 10
            TCPKeepAlive yes
            Compression no
            ControlMaster auto
            ControlPath ~/.ssh/control-%h-%p-%r
            ControlPersist 10m
          EOF
          chmod 600 ~/.ssh/config
          
          # Test SSH connection
          echo "üîç Testing SSH connection..."
          ssh -i "$KEY_FILE" -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes root@${{ secrets.STAGING_HOST }} "echo 'SSH connection successful'" || {
            echo "‚ùå SSH connection test failed"
            echo "Key file: $KEY_FILE"
            echo "Key file exists: $(test -f "$KEY_FILE" && echo 'yes' || echo 'no')"
            if [ -f "$KEY_FILE" ]; then
              echo "Key file permissions: $(ls -la "$KEY_FILE")"
              echo "Key file first line: $(head -n1 "$KEY_FILE")"
              echo "Key file last line: $(tail -n1 "$KEY_FILE")"
            fi
            echo ""
            echo "üí° Troubleshooting tips:"
            echo "1. Ensure STAGING_SSH_KEY secret includes the full private key with headers"
            echo "2. Verify the key is added to the server's authorized_keys"
            echo "3. Check that STAGING_HOST is correct"
            exit 1
          }
          
          # Export key file path for use in deployment step
          echo "KEY_FILE=$KEY_FILE" >> $GITHUB_ENV
          echo "‚úÖ SSH setup complete. Using key: $KEY_FILE"

      - name: Deploy to staging
        run: |
          # Try to use detected key file, fallback to common key types
          if [ -f "${{ env.KEY_FILE }}" ]; then
            KEY_FILE="${{ env.KEY_FILE }}"
          elif [ -f ~/.ssh/id_ed25519 ]; then
            KEY_FILE=~/.ssh/id_ed25519
          elif [ -f ~/.ssh/id_rsa ]; then
            KEY_FILE=~/.ssh/id_rsa
          else
            echo "‚ùå No SSH key found"
            exit 1
          fi
          
          # Use SSH with keepalive and run deployment in a way that won't timeout
          ssh -i "$KEY_FILE" \
            -o StrictHostKeyChecking=no \
            -o BatchMode=yes \
            -o ServerAliveInterval=60 \
            -o ServerAliveCountMax=10 \
            -o TCPKeepAlive=yes \
            root@${{ secrets.STAGING_HOST }} << 'DEPLOY_SCRIPT'
          set -e  # Exit on error
          
          echo "üöÄ Starting deployment..."
          cd /opt/stackyn
          
          # Backup current deployment
          echo "üì¶ Creating backup..."
          if [ -d ".git" ]; then
            git stash || true
            CURRENT_COMMIT=$(git rev-parse HEAD)
            echo "Current commit: $CURRENT_COMMIT"
          fi
          
          # Pull latest code
          echo "üì• Pulling latest code..."
          git checkout develop
          git pull origin develop
          NEW_COMMIT=$(git rev-parse HEAD)
          echo "New commit: $NEW_COMMIT"
          
          # Ensure environment variables are set
          echo "üîç Checking environment configuration..."
          if [ ! -f .env ]; then
            echo "‚ö†Ô∏è  Warning: .env file not found."
            # Try env.example first (the actual file name), then .env.production.example as fallback
            if [ -f env.example ]; then
              echo "üìã Creating .env from env.example template..."
              cp env.example .env
              echo "‚úÖ Created .env from env.example"
            elif [ -f .env.production.example ]; then
              echo "üìã Creating .env from .env.production.example template..."
              cp .env.production.example .env
              echo "‚úÖ Created .env from .env.production.example"
            else
              echo "‚ùå No .env file or template found. Deployment cannot continue."
              echo "   Looking for: env.example or .env.production.example"
              exit 1
            fi
          else
            echo "‚úÖ .env file exists"
            # Check if APP_BASE_DOMAIN is missing and add it if needed
            if ! grep -q "^APP_BASE_DOMAIN=" .env; then
              echo "‚ö†Ô∏è  APP_BASE_DOMAIN not found in .env, adding it..."
              if [ -f env.example ] && grep -q "^APP_BASE_DOMAIN=" env.example; then
                # Extract APP_BASE_DOMAIN from env.example and append to .env
                grep "^APP_BASE_DOMAIN=" env.example >> .env
                echo "‚úÖ Added APP_BASE_DOMAIN to .env"
              else
                # Add default value (use stackyn.com as default)
                echo "APP_BASE_DOMAIN=staging.stackyn.com" >> .env
                echo "‚úÖ Added APP_BASE_DOMAIN=staging.stackyn.com to .env"
              fi
            fi
          fi

            # FORCE UPDATE to production domains
            echo "üîß Enforcing production domains in .env..."
            sed -i 's|FRONTEND_API_URL=.*|FRONTEND_API_URL=https://api.staging.stackyn.com|g' .env
            sed -i 's|FRONTEND_DOMAIN=.*|FRONTEND_DOMAIN=staging.stackyn.com|g' .env
            sed -i 's|API_DOMAIN=.*|API_DOMAIN=api.staging.stackyn.com|g' .env
            sed -i 's|CONSOLE_DOMAIN=.*|CONSOLE_DOMAIN=console.staging.stackyn.com|g' .env
            sed -i 's|APP_BASE_DOMAIN=.*|APP_BASE_DOMAIN=staging.stackyn.com|g' .env
            echo "‚úÖ Updated .env to use staging.stackyn.com domains"
          
          # Verify critical environment variables are set
          echo "‚úÖ Verifying critical environment variables..."
          source .env || true
          MISSING_VARS=()
          [ -z "$POSTGRES_PASSWORD" ] && MISSING_VARS+=("POSTGRES_PASSWORD")
          [ -z "$JWT_SECRET" ] && MISSING_VARS+=("JWT_SECRET")
          [ -z "$API_DOMAIN" ] && MISSING_VARS+=("API_DOMAIN")
          [ -z "$APP_BASE_DOMAIN" ] && MISSING_VARS+=("APP_BASE_DOMAIN")
          [ -z "$ACME_EMAIL" ] && MISSING_VARS+=("ACME_EMAIL")
          
          if [ ${#MISSING_VARS[@]} -ne 0 ]; then
            echo "‚ùå Missing required environment variables:"
            for var in "${MISSING_VARS[@]}"; do
              echo "   - $var"
            done
            echo ""
            echo "üí° Solution:"
            echo "   1. SSH into the VPS: ssh root@${{ secrets.STAGING_HOST }}"
            echo "   2. Edit .env: cd /opt/stackyn && nano .env"
            echo "   3. Add missing variables (see env.example for format)"
            echo "   4. Redeploy"
            exit 1
          fi
          
          echo "‚úÖ All required environment variables are set"
          
          echo "‚úÖ Environment variables verified"
          
          # Build and deploy
          echo "üî® Building and deploying containers..."
          
          COMPOSE_FILE="docker-compose.yml"
          
          # Ensure SSL certificate volume exists and is preserved
          SSL_VOLUME_NAME="stackyn_traefik_data"
          echo "üîê Ensuring SSL certificates are ready..."
          docker volume inspect "$SSL_VOLUME_NAME" >/dev/null 2>&1 && echo "‚úÖ SSL certificate volume exists and will be preserved" || echo "‚ö†Ô∏è  SSL certificate volume not found (will be created)"
          
          docker volume inspect "$SSL_VOLUME_NAME" >/dev/null 2>&1 || docker volume create "$SSL_VOLUME_NAME"
          
          # Initialize acme.json if needed (preserve existing certificates)
          docker run --rm -v "$SSL_VOLUME_NAME:/letsencrypt" alpine sh -c "
            if [ ! -f /letsencrypt/acme.json ]; then
              echo 'Creating new acme.json file...'
              touch /letsencrypt/acme.json
              chmod 600 /letsencrypt/acme.json
              echo '{}' > /letsencrypt/acme.json
            else
              CERT_SIZE=\$(stat -c%s /letsencrypt/acme.json 2>/dev/null || echo 0)
              if [ \$CERT_SIZE -lt 100 ]; then
                echo 'acme.json exists but is too small, initializing...'
                echo '{}' > /letsencrypt/acme.json
                chmod 600 /letsencrypt/acme.json
              else
                echo 'Existing acme.json found (\$CERT_SIZE bytes) - preserving certificates'
              fi
            fi
          " || true
          
          # Build new images
          echo "üì¶ Building new images..."
          if ! docker compose -f "$COMPOSE_FILE" build --no-cache; then
            echo "‚ùå Build failed. Showing recent logs:"
            docker compose build --no-cache 2>&1 | tail -n 100
            exit 1
          fi
          
          # Stop old containers and start new ones
          echo "üöÄ Starting containers..."
          docker compose -f "$COMPOSE_FILE" up -d --remove-orphans
          
          # Wait for containers to start
          echo "‚è≥ Waiting for containers to start..."
          sleep 10
          
          # Verify containers are running
          echo "üîç Verifying containers are running..."
          if docker compose -f "$COMPOSE_FILE" ps | grep -q "Up"; then
            echo "‚úÖ All services are running"
            docker compose -f "$COMPOSE_FILE" ps
          else
            echo "‚ùå Some services failed to start"
            docker compose -f "$COMPOSE_FILE" ps
            echo "üìã Recent logs:"
            docker compose -f "$COMPOSE_FILE" logs --tail=50
            exit 1
          fi
          
          # Final health check
          echo "üè• Final health check..."
          sleep 10
          
          # Verify API is responding
          echo "üîç Verifying API health..."
          API_URL="https://${API_DOMAIN:-api.staging.stackyn.com}/health"
          if curl -f -s "$API_URL" >/dev/null 2>&1; then
            echo "‚úÖ API health check passed"
          else
            echo "‚ö†Ô∏è  API health check failed (may need more time or SSL certificate)"
            echo "   URL: $API_URL"
            echo "   This is normal if SSL certificates are still being generated."
          fi
          
          # Show recent logs
          echo "üìã Recent logs:"
          docker compose -f "$COMPOSE_FILE" logs --tail=20
          
          echo ""
          echo "‚úÖ Deployment completed successfully!"
          echo "üåê Access your application at:"
          echo "   - Landing: https://${FRONTEND_DOMAIN:-staging.stackyn.com}"
          echo "   - API: https://${API_DOMAIN:-api.staging.stackyn.com}"
          echo ""
          echo "üí° SSL certificates may take 5-10 minutes to generate on first deployment."
          DEPLOY_SCRIPT

      - name: Deployment status
        if: failure()
        run: |
          echo "‚ùå Deployment failed. Check the logs above for details."
          exit 1
